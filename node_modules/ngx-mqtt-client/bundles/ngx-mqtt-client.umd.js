(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('mqtt'), require('rxjs/Observable'), require('rxjs/Subject'), require('rxjs/observable/fromPromise'), require('rxjs/operators'), require('rxjs/observable/of'), require('rxjs/BehaviorSubject'), require('rxjs/add/observable/throw'), require('rxjs/observable/concat')) :
	typeof define === 'function' && define.amd ? define('ngx-mqtt-client', ['exports', '@angular/core', 'mqtt', 'rxjs/Observable', 'rxjs/Subject', 'rxjs/observable/fromPromise', 'rxjs/operators', 'rxjs/observable/of', 'rxjs/BehaviorSubject', 'rxjs/add/observable/throw', 'rxjs/observable/concat'], factory) :
	(factory((global['ngx-mqtt-client'] = {}),global.ng.core,global.mqtt,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx,global.Rx.Observable,global.Rx.Observable));
}(this, (function (exports,core,mqtt,Observable,Subject,fromPromise,operators,of,BehaviorSubject,_throw,concat) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var MQTT_CONFIG = new core.InjectionToken('mqtt configuration');
var SubscriptionGrant = /** @class */ (function () {
    function SubscriptionGrant(grant) {
        this.topic = grant.topic;
        this.qos = grant.qos;
    }
    return SubscriptionGrant;
}());
var MQTT_MOCK = new core.InjectionToken('mqtt mock');
var MqttService = /** @class */ (function () {
    function MqttService(config, _mqttMock) {
        this._mqttMock = _mqttMock;
        this._status = new BehaviorSubject.BehaviorSubject(0);
        this._store = {};
        if (!config.manageConnectionManually) {
            this.connect(config);
        }
    }
    MqttService.prototype.connect = function (config) {
        var _this = this;
        if (this._client && this._client.connected) {
            this._client.end(true);
        }
        this._client = this._mqttMock ? this._mqttMock.connect(null, config) : mqtt.connect(null, config);
        this._client.on('message', function (topic, message) { return _this.updateTopic(topic, message.toString()); });
        this._client.on('offline', function () { return _this._status.next(1); });
        this._client.on('connect', function () { return _this._status.next(0); });
    };
    MqttService.prototype.subscribeTo = function (topic, options) {
        var _this = this;
        return this._status.pipe(operators.switchMap(function (status) {
            if (status === 1) {
                return _this.throwError();
            }
            if (_this._store[topic]) {
                var grant = _this._store[topic].grant;
                var stream = _this._store[topic].stream;
                stream.observers.forEach(function (obs) { return obs.complete(); });
                return concat.concat(of.of(grant), stream);
            }
            return fromPromise.fromPromise(new Promise(function (resolve, reject) {
                _this._client.subscribe(topic, options, function (error, granted) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        var qos = options ? options.qos : 0;
                        var grantedWorkaround = granted.length > 0 ? new SubscriptionGrant(granted[0]) : new SubscriptionGrant({
                            topic: topic,
                            qos: qos
                        });
                        resolve(grantedWorkaround);
                    }
                });
            })).pipe(operators.switchMap(function (granted) { return concat.concat(of.of(granted), _this.addTopic(topic, granted)); }));
        }));
    };
    MqttService.prototype.unsubscribeFrom = function (topic) {
        var _this = this;
        if (Array.isArray(topic)) {
            topic.forEach(function (t) {
                _this.removeTopic(t);
            });
        }
        else {
            this.removeTopic(topic);
        }
        return fromPromise.fromPromise(new Promise(function (resolve, reject) {
            _this._client.unsubscribe(topic, function (error) { return error ? reject(error) : resolve(); });
        }));
    };
    MqttService.prototype.publishTo = function (topic, message, options) {
        var _this = this;
        return fromPromise.fromPromise(new Promise(function (resolve, reject) {
            var msg;
            if (!(message instanceof Buffer)) {
                switch (typeof message) {
                    case 'string':
                    case 'number':
                    case 'boolean':
                        msg = message.toString();
                        break;
                    case 'object':
                        msg = JSON.stringify(message);
                        break;
                }
            }
            else {
                msg = message;
            }
            _this._client.publish(topic, msg, options, function (error) { return error ? reject(error) : resolve(); });
        }));
    };
    MqttService.prototype.end = function (force, cb) {
        var topics = Object.keys(this._store);
        this.unsubscribeFrom(topics);
        this._status.unsubscribe();
        this._client.end(force, cb);
    };
    MqttService.prototype.status = function () {
        return this._status.pipe(operators.distinctUntilChanged());
    };
    MqttService.prototype.removeTopic = function (topic) {
        if (this._store[topic]) {
            this._store[topic].stream.unsubscribe();
            var _a = this._store, _b = topic, removed = _a[_b], newStore = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this._store = newStore;
        }
    };
    MqttService.prototype.updateTopic = function (topic, message) {
        var msg;
        try {
            msg = JSON.parse(message);
        }
        catch (ex) {
            msg = message;
        }
        this._store[topic].stream.next(msg);
    };
    MqttService.prototype.addTopic = function (topic, grant) {
        this._store[topic] = { grant: grant, stream: new Subject.Subject() };
        return this._store[topic].stream;
    };
    MqttService.prototype.throwError = function () {
        return Observable.Observable.throw(new Error('No connection with MQTT.'));
    };
    return MqttService;
}());
MqttService.decorators = [
    { type: core.Injectable },
];
MqttService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [MQTT_CONFIG,] },] },
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MQTT_MOCK,] },] },
]; };
var NgxMqttClientModule = /** @class */ (function () {
    function NgxMqttClientModule() {
    }
    NgxMqttClientModule.withOptions = function (config) {
        return {
            ngModule: NgxMqttClientModule,
            providers: [
                { provide: MQTT_CONFIG, useValue: config }
            ]
        };
    };
    return NgxMqttClientModule;
}());
NgxMqttClientModule.decorators = [
    { type: core.NgModule, args: [{
                providers: [MqttService]
            },] },
];
NgxMqttClientModule.ctorParameters = function () { return []; };

exports.MqttService = MqttService;
exports.NgxMqttClientModule = NgxMqttClientModule;
exports.SubscriptionGrant = SubscriptionGrant;
exports.ɵa = MQTT_CONFIG;
exports.ɵb = MQTT_MOCK;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-mqtt-client.umd.js.map
