import { InjectionToken, Inject, Injectable, Optional, NgModule } from '@angular/core';
import { __rest } from 'tslib';
import { connect } from 'mqtt';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { fromPromise } from 'rxjs/observable/fromPromise';
import { distinctUntilChanged, switchMap } from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/throw';
import { concat } from 'rxjs/observable/concat';

var MQTT_CONFIG = new InjectionToken('mqtt configuration');
var SubscriptionGrant = /** @class */ (function () {
    function SubscriptionGrant(grant) {
        this.topic = grant.topic;
        this.qos = grant.qos;
    }
    return SubscriptionGrant;
}());
var MQTT_MOCK = new InjectionToken('mqtt mock');
var MqttService = /** @class */ (function () {
    function MqttService(config, _mqttMock) {
        this._mqttMock = _mqttMock;
        this._status = new BehaviorSubject(0);
        this._store = {};
        if (!config.manageConnectionManually) {
            this.connect(config);
        }
    }
    MqttService.prototype.connect = function (config) {
        var _this = this;
        if (this._client && this._client.connected) {
            this._client.end(true);
        }
        this._client = this._mqttMock ? this._mqttMock.connect(null, config) : connect(null, config);
        this._client.on('message', function (topic, message) { return _this.updateTopic(topic, message.toString()); });
        this._client.on('offline', function () { return _this._status.next(1); });
        this._client.on('connect', function () { return _this._status.next(0); });
    };
    MqttService.prototype.subscribeTo = function (topic, options) {
        var _this = this;
        return this._status.pipe(switchMap(function (status) {
            if (status === 1) {
                return _this.throwError();
            }
            if (_this._store[topic]) {
                var grant = _this._store[topic].grant;
                var stream = _this._store[topic].stream;
                stream.observers.forEach(function (obs) { return obs.complete(); });
                return concat(of(grant), stream);
            }
            return fromPromise(new Promise(function (resolve, reject) {
                _this._client.subscribe(topic, options, function (error, granted) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        var qos = options ? options.qos : 0;
                        var grantedWorkaround = granted.length > 0 ? new SubscriptionGrant(granted[0]) : new SubscriptionGrant({
                            topic: topic,
                            qos: qos
                        });
                        resolve(grantedWorkaround);
                    }
                });
            })).pipe(switchMap(function (granted) { return concat(of(granted), _this.addTopic(topic, granted)); }));
        }));
    };
    MqttService.prototype.unsubscribeFrom = function (topic) {
        var _this = this;
        if (Array.isArray(topic)) {
            topic.forEach(function (t) {
                _this.removeTopic(t);
            });
        }
        else {
            this.removeTopic(topic);
        }
        return fromPromise(new Promise(function (resolve, reject) {
            _this._client.unsubscribe(topic, function (error) { return error ? reject(error) : resolve(); });
        }));
    };
    MqttService.prototype.publishTo = function (topic, message, options) {
        var _this = this;
        return fromPromise(new Promise(function (resolve, reject) {
            var msg;
            if (!(message instanceof Buffer)) {
                switch (typeof message) {
                    case 'string':
                    case 'number':
                    case 'boolean':
                        msg = message.toString();
                        break;
                    case 'object':
                        msg = JSON.stringify(message);
                        break;
                }
            }
            else {
                msg = message;
            }
            _this._client.publish(topic, msg, options, function (error) { return error ? reject(error) : resolve(); });
        }));
    };
    MqttService.prototype.end = function (force, cb) {
        var topics = Object.keys(this._store);
        this.unsubscribeFrom(topics);
        this._status.unsubscribe();
        this._client.end(force, cb);
    };
    MqttService.prototype.status = function () {
        return this._status.pipe(distinctUntilChanged());
    };
    MqttService.prototype.removeTopic = function (topic) {
        if (this._store[topic]) {
            this._store[topic].stream.unsubscribe();
            var _a = this._store, _b = topic, removed = _a[_b], newStore = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this._store = newStore;
        }
    };
    MqttService.prototype.updateTopic = function (topic, message) {
        var msg;
        try {
            msg = JSON.parse(message);
        }
        catch (ex) {
            msg = message;
        }
        this._store[topic].stream.next(msg);
    };
    MqttService.prototype.addTopic = function (topic, grant) {
        this._store[topic] = { grant: grant, stream: new Subject() };
        return this._store[topic].stream;
    };
    MqttService.prototype.throwError = function () {
        return Observable.throw(new Error('No connection with MQTT.'));
    };
    return MqttService;
}());
MqttService.decorators = [
    { type: Injectable },
];
MqttService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: [MQTT_CONFIG,] },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MQTT_MOCK,] },] },
]; };
var NgxMqttClientModule = /** @class */ (function () {
    function NgxMqttClientModule() {
    }
    NgxMqttClientModule.withOptions = function (config) {
        return {
            ngModule: NgxMqttClientModule,
            providers: [
                { provide: MQTT_CONFIG, useValue: config }
            ]
        };
    };
    return NgxMqttClientModule;
}());
NgxMqttClientModule.decorators = [
    { type: NgModule, args: [{
                providers: [MqttService]
            },] },
];
NgxMqttClientModule.ctorParameters = function () { return []; };

export { MqttService, NgxMqttClientModule, SubscriptionGrant, MQTT_CONFIG as ɵa, MQTT_MOCK as ɵb };
//# sourceMappingURL=ngx-mqtt-client.js.map
