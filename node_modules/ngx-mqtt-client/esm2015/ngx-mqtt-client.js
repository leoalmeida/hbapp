import { InjectionToken, Inject, Injectable, Optional, NgModule } from '@angular/core';
import { __rest } from 'tslib';
import { connect } from 'mqtt';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { fromPromise } from 'rxjs/observable/fromPromise';
import { distinctUntilChanged, switchMap } from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/throw';
import { concat } from 'rxjs/observable/concat';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MQTT_CONFIG = new InjectionToken('mqtt configuration');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SubscriptionGrant {
    /**
     * @param {?} grant
     */
    constructor(grant) {
        this.topic = grant.topic;
        this.qos = grant.qos;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MQTT_MOCK = new InjectionToken('mqtt mock');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MqttService {
    /**
     * @param {?} config
     * @param {?} _mqttMock
     */
    constructor(config, _mqttMock) {
        this._mqttMock = _mqttMock;
        this._status = new BehaviorSubject(0 /* CONNECTED */);
        this._store = {};
        if (!config.manageConnectionManually) {
            this.connect(config);
        }
    }
    /**
     * @param {?} config
     * @return {?}
     */
    connect(config) {
        if (this._client && this._client.connected) {
            this._client.end(true);
        }
        this._client = this._mqttMock ? this._mqttMock.connect(null, config) : connect(null, config);
        this._client.on('message', (topic, message) => this.updateTopic(topic, message.toString()));
        this._client.on('offline', () => this._status.next(1 /* DISCONNECTED */));
        this._client.on('connect', () => this._status.next(0 /* CONNECTED */));
    }
    /**
     * @template T
     * @param {?} topic
     * @param {?=} options
     * @return {?}
     */
    subscribeTo(topic, options) {
        return this._status.pipe(switchMap(status => {
            if (status === 1 /* DISCONNECTED */) {
                return this.throwError();
            }
            if (this._store[topic]) {
                const /** @type {?} */ grant = this._store[topic].grant;
                const /** @type {?} */ stream = this._store[topic].stream;
                stream.observers.forEach(obs => obs.complete());
                return concat(of(grant), stream);
            }
            return fromPromise(new Promise((resolve, reject) => {
                this._client.subscribe(topic, options, (error, granted) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        // https://github.com/mqttjs/MQTT.js/issues/529
                        // workaround until they fix this issue
                        const /** @type {?} */ qos = options ? options.qos : 0;
                        const /** @type {?} */ grantedWorkaround = granted.length > 0 ? new SubscriptionGrant(granted[0]) : new SubscriptionGrant({
                            topic,
                            qos
                        });
                        resolve(grantedWorkaround);
                    }
                });
            })).pipe(switchMap((granted) => concat(of(granted), this.addTopic(topic, granted))));
        }));
    }
    /**
     * @param {?} topic
     * @return {?}
     */
    unsubscribeFrom(topic) {
        if (Array.isArray(topic)) {
            topic.forEach(t => {
                this.removeTopic(t);
            });
        }
        else {
            this.removeTopic(topic);
        }
        return fromPromise(new Promise((resolve, reject) => {
            this._client.unsubscribe(topic, (error) => error ? reject(error) : resolve());
        }));
    }
    /**
     * @template T
     * @param {?} topic
     * @param {?} message
     * @param {?=} options
     * @return {?}
     */
    publishTo(topic, message, options) {
        return fromPromise(new Promise((resolve, reject) => {
            let /** @type {?} */ msg;
            if (!(message instanceof Buffer)) {
                switch (typeof message) {
                    case 'string':
                    case 'number':
                    case 'boolean':
                        msg = message.toString();
                        break;
                    case 'object':
                        msg = JSON.stringify(message);
                        break;
                }
            }
            else {
                msg = message;
            }
            this._client.publish(topic, msg, options, (error) => error ? reject(error) : resolve());
        }));
    }
    /**
     * @param {?=} force
     * @param {?=} cb
     * @return {?}
     */
    end(force, cb) {
        const /** @type {?} */ topics = Object.keys(this._store);
        this.unsubscribeFrom(topics);
        this._status.unsubscribe();
        this._client.end(force, cb);
    }
    /**
     * @return {?}
     */
    status() {
        return this._status.pipe(distinctUntilChanged());
    }
    /**
     * @param {?} topic
     * @return {?}
     */
    removeTopic(topic) {
        if (this._store[topic]) {
            this._store[topic].stream.unsubscribe();
            const _a = this._store, _b = topic, removed = _a[_b], newStore = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this._store = newStore;
        }
    }
    /**
     * @param {?} topic
     * @param {?} message
     * @return {?}
     */
    updateTopic(topic, message) {
        let /** @type {?} */ msg;
        try {
            msg = JSON.parse(message);
        }
        catch (/** @type {?} */ ex) {
            msg = message;
        }
        this._store[topic].stream.next(msg);
    }
    /**
     * @template T
     * @param {?} topic
     * @param {?} grant
     * @return {?}
     */
    addTopic(topic, grant) {
        this._store[topic] = { grant, stream: new Subject() };
        return this._store[topic].stream;
    }
    /**
     * @return {?}
     */
    throwError() {
        return Observable.throw(new Error('No connection with MQTT.'));
    }
}
MqttService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
MqttService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MQTT_CONFIG,] },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MQTT_MOCK,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMqttClientModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static withOptions(config) {
        return {
            ngModule: NgxMqttClientModule,
            providers: [
                { provide: MQTT_CONFIG, useValue: config }
            ]
        };
    }
}
NgxMqttClientModule.decorators = [
    { type: NgModule, args: [{
                providers: [MqttService]
            },] },
];
/** @nocollapse */
NgxMqttClientModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { MqttService, NgxMqttClientModule, SubscriptionGrant, MQTT_CONFIG as ɵa, MQTT_MOCK as ɵb };
//# sourceMappingURL=ngx-mqtt-client.js.map
